<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>GNSS Orbit Visualisierung (Kepler)</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: Arial, sans-serif; overflow: hidden; display: flex; height: 100vh; }
        #main-container { display: flex; flex-grow: 1; overflow: hidden; }
        #canvas-container { flex-grow: 1; position: relative; }
        #sidebar { width: 320px; background-color: #111; border-left: 1px solid #333; display: flex; flex-direction: column; }
        #sidebar-header { padding: 15px; background-color: #1a1a1a; border-bottom: 1px solid #333; }
        #filter-container { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px; }
        .filter-btn { flex: 1; background: #222; border: 1px solid #444; color: #aaa; padding: 5px; cursor: pointer; font-size: 12px; }
        .filter-btn:hover { background: #333; color: #fff; }
        .filter-btn.active { background: #444; color: #fff; border-color: #fff; }
        
        /* System Farben */
        .filter-btn[data-sys="GPS"].active { border-color: #00ff00; color: #00ff00; }
        .filter-btn[data-sys="GLO"].active { border-color: #ff0000; color: #ff0000; }
        .filter-btn[data-sys="GAL"].active { border-color: #ffff00; color: #ffff00; }
        .filter-btn[data-sys="BDS"].active { border-color: #0088ff; color: #0088ff; }

        #sat-list-container { flex-grow: 1; overflow-y: auto; }
        #sat-list { list-style: none; padding: 0; margin: 0; }
        #sat-list li { padding: 8px 15px; border-bottom: 1px solid #222; cursor: pointer; font-size: 13px; display: flex; justify-content: space-between; }
        #sat-list li:hover { background-color: #222; }
        #sat-list li.active { background-color: #004444; color: #00ffff; }
        
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); padding: 20px; border-radius: 8px; pointer-events: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>

<div id="main-container">
    <div id="canvas-container">
        <div id="loader">Lade GNSS Daten...</div>
    </div>
    <div id="sidebar">
        <div id="sidebar-header">
            <h3>GNSS Konstellationen</h3>
            <div id="filter-container">
                <button class="filter-btn active" data-sys="ALL">ALLE</button>
                <button class="filter-btn" data-sys="GPS">GPS</button>
                <button class="filter-btn" data-sys="GLO">GLONASS</button>
                <button class="filter-btn" data-sys="GAL">GALILEO</button>
                <button class="filter-btn" data-sys="BDS">BEIDOU</button>
            </div>
        </div>
        <div id="sat-list-container">
            <ul id="sat-list"></ul>
        </div>
    </div>
</div>

<script>
    // --- KONFIGURATION ---
    const SCALE = 5 / 6371; // Erdradius (km) auf Three.js Einheiten (5)
    const GM = 398600.4418; // Gravitationskonstante Erde (km^3/s^2)
    const EARTH_RADIUS_KM = 6371;

    let scene, camera, renderer, controls, earth;
    let satellites = []; // Speichert alle Satelliten-Objekte
    let currentFilter = 'ALL';

    // Initialisierung
    async function init() {
        scene = new THREE.Scene();
        const container = document.getElementById('canvas-container');

        camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 20, 40);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Licht
        scene.add(new THREE.AmbientLight(0x404040));
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(50, 20, 30);
        scene.add(sunLight);

        // Erde laden
        try {
            // Fallback Kugel, falls kein GLTF da ist, oder GLTF laden
            const gltfLoader = new THREE.GLTFLoader();
            // Versuche earth.glb zu laden, sonst blaue Kugel
            try {
                const earthGltf = await gltfLoader.loadAsync('earth.glb');
                earth = earthGltf.scene;
                earth.scale.set(5, 5, 5);
            } catch(err) {
                const geo = new THREE.SphereGeometry(5, 32, 32);
                const mat = new THREE.MeshPhongMaterial({ color: 0x2233ff, wireframe: true });
                earth = new THREE.Mesh(geo, mat);
            }

        
            scene.add(earth);

        } catch (e) { console.error(e); }

        // Daten laden
        loadSatellites();

        // Events
        setupUI();
        window.addEventListener('resize', onResize);
        animate();
    }

    async function loadSatellites() {
        try {
            const res = await fetch('gnss.json');
            const data = await res.json();
            processData(data);
            document.getElementById('loader').style.display = 'none';
        } catch (e) {
            document.getElementById('loader').innerText = "Fehler: gnss.json nicht gefunden!";
        }
    }

    function processData(data) {
        data.forEach(satData => {
            // System bestimmen
            let system = 'OTHER';
            let color = 0xaaaaaa;
            const name = satData.OBJECT_NAME.toUpperCase();

            if (name.includes('GPS')) { system = 'GPS'; color = 0x00ff00; }
            else if (name.includes('BEIDOU')) { system = 'BDS'; color = 0x0088ff; }
            else if (name.includes('GALILEO') || name.includes('GSAT')) { system = 'GAL'; color = 0xffff00; }
            else if (name.includes('COSMOS') || name.includes('GLONASS')) { system = 'GLO'; color = 0xff0000; }

            // Kepler Parameter extrahieren
            const kepler = {
                n: satData.MEAN_MOTION, // revs per day
                e: satData.ECCENTRICITY,
                i: satData.INCLINATION * (Math.PI/180),
                raan: satData.RA_OF_ASC_NODE * (Math.PI/180),
                argPe: satData.ARG_OF_PERICENTER * (Math.PI/180),
                ma: satData.MEAN_ANOMALY * (Math.PI/180),
                a: 0 // wird berechnet
            };

            // Große Halbachse (a) berechnen aus Mean Motion
            // n in rad/s umrechnen: n * 2pi / 86400
            const n_rad_s = kepler.n * (2 * Math.PI) / 86400;
            kepler.a = Math.cbrt(GM / (n_rad_s * n_rad_s)); 

            // Visualisierung erstellen
            const orbitObj = createOrbitVisuals(kepler, color);
            
            const satEntry = {
                mesh: orbitObj.mesh,
                orbitLine: orbitObj.line,
                data: satData,
                kepler: kepler,
                system: system,
                color: color
            };
            
            satellites.push(satEntry);
            scene.add(orbitObj.mesh);
            scene.add(orbitObj.line);
        });

        updateFilter();
    }

    // --- PHYSIK TEIL (Kepler zu Kartesisch) ---
    function getPositionAtAnomaly(kepler, trueAnomaly) {
        // Radius berechnen: r = a(1-e^2) / (1 + e*cos(v))
        const r = (kepler.a * (1 - kepler.e * kepler.e)) / (1 + kepler.e * Math.cos(trueAnomaly));
        
        // Position in Orbit-Ebene
        const x_orb = r * Math.cos(trueAnomaly);
        const y_orb = r * Math.sin(trueAnomaly);

        // Rotationen anwenden (Arg of Periapsis, Inclination, RAAN)
        // 1. Um Z drehen (Arg Periapsis)
        const x1 = x_orb * Math.cos(kepler.argPe) - y_orb * Math.sin(kepler.argPe);
        const y1 = x_orb * Math.sin(kepler.argPe) + y_orb * Math.cos(kepler.argPe);
        
        // 2. Um X drehen (Inklination)
        const x2 = x1;
        const y2 = y1 * Math.cos(kepler.i);
        const z2 = y1 * Math.sin(kepler.i);

        // 3. Um Z drehen (RAAN)
        const X = x2 * Math.cos(kepler.raan) - y2 * Math.sin(kepler.raan);
        const Y = x2 * Math.sin(kepler.raan) + y2 * Math.cos(kepler.raan);
        const Z = z2;

        // Three.js Koordinatensystem anpassen (Y ist oben in Three.js, Z oft oben in Astronomie, hier Mapping auf Y-Up)
        // Wir mappen Astronomie X/Y/Z -> Three X/Z/-Y oder ähnlich. 
        // Standard ECI: Z ist Nordpol. In ThreeJS ist Y meist oben.
        // Wir tauschen Y und Z und skalieren.
        return new THREE.Vector3(X * SCALE, Z * SCALE, -Y * SCALE);
    }

    function solveKepler(M, e) {
        // Newton Iteration für Exzentrische Anomalie E
        let E = M;
        for(let i=0; i<10; i++) {
            E = M + e * Math.sin(E);
        }
        return E;
    }

    function createOrbitVisuals(kepler, color) {
        // 1. Orbit Linie zeichnen (statisch)
        const points = [];
        const segments = 128;
        for (let i = 0; i <= segments; i++) {
            // Wahre Anomalie von 0 bis 2PI durchlaufen
            const v = (i / segments) * 2 * Math.PI;
            points.push(getPositionAtAnomaly(kepler, v));
        }
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.3 });
        const line = new THREE.LineLoop(geometry, material);

        // 2. Satelliten Mesh
        const satGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const satMat = new THREE.MeshBasicMaterial({ color: color });
        const mesh = new THREE.Mesh(satGeo, satMat);

        return { line, mesh };
    }

    // --- UI & FILTER ---
    function setupUI() {
        const buttons = document.querySelectorAll('.filter-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.sys;
                updateFilter();
            });
        });
    }

    function updateFilter() {
        const list = document.getElementById('sat-list');
        list.innerHTML = '';

        satellites.forEach(sat => {
            const visible = (currentFilter === 'ALL' || sat.system === currentFilter);
            
            sat.mesh.visible = visible;
            sat.orbitLine.visible = visible;

            if (visible) {
                const li = document.createElement('li');
                li.innerHTML = `<span>${sat.data.OBJECT_NAME}</span>`;
                li.style.borderLeft = `3px solid #${sat.color.toString(16).padStart(6,'0')}`;
                
                li.addEventListener('click', () => {
                    // Kamera Fokus Logik hier optional
                    // sat.mesh.scale.set(2,2,2); ...
                });
                list.appendChild(li);
            }
        });
    }

    // --- ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);

        const now = Date.now() * 0.0005; // Zeit-Skalierung

        satellites.forEach(sat => {
            if (!sat.mesh.visible) return;

            // Einfache Bewegung basierend auf Mean Anomaly + Zeit
            // (Für echte Position bräuchte man die genaue Epochen-Zeit)
            const deltaM = sat.kepler.n * (2*Math.PI/86400) * (Date.now() * 0.5); // Speed Factor 100
            
            let M = sat.kepler.ma + deltaM; 
            const E = solveKepler(M, sat.kepler.e);
            
            // Wahre Anomalie v berechnen
            // tan(v/2) = sqrt((1+e)/(1-e)) * tan(E/2)
            const v = 2 * Math.atan(Math.sqrt((1+sat.kepler.e)/(1-sat.kepler.e)) * Math.tan(E/2));

            const pos = getPositionAtAnomaly(sat.kepler, v);
            sat.mesh.position.copy(pos);
        });

        controls.update();
        renderer.render(scene, camera);
    }

    function onResize() {
        const container = document.getElementById('canvas-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    init();
</script>
</body>
</html>