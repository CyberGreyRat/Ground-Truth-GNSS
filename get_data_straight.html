<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIVE 3D Satelliten (V4.4: Solo & Permanent)</title>

    <style>
        /* CSS bleibt identisch zu vorher */
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #main-container {
            display: flex;
            flex-direction: row;
            flex-grow: 1;
            overflow: hidden;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: grab;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            color: #00ffff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            text-align: center;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
        }

        #time-display {
            margin-top: 5px;
            font-size: 1.2em;
            color: #00ffff;
        }

        #controls {
            padding: 10px;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            gap: 10px;
            border-top: 1px solid #00ffff;
            flex-wrap: wrap;
        }

        button,
        select {
            padding: 5px 10px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            cursor: pointer;
        }

        button:hover,
        select:hover {
            background: #00ffff;
            color: #000;
        }

        .label-text {
            color: rgba(246, 255, 0, 0.8);
            font-size: 12px;
            font-family: monospace;
            white-space: nowrap;
            cursor: pointer;
            pointer-events: auto;
        }

        #data-sidebar {
            width: 350px;
            background: rgba(10, 20, 30, 0.9);
            border-left: 1px solid #00ffff;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        #satellite-table-container {
            flex-grow: 1;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        th {
            position: sticky;
            top: 0;
            background: #1a1a1a;
            color: #00ffff;
            border-bottom: 1px solid #00ffff;
        }

        td {
            padding: 4px;
            text-align: right;
            color: #ddd;
        }

        tr:nth-child(even) {
            background: rgba(0, 255, 255, 0.05);
        }

        tr:hover {
            background-color: rgba(0, 255, 255, 0.2);
            cursor: pointer;
        }

        /* Checkbox Styling */
        input[type="checkbox"] {
            cursor: pointer;
            transform: scale(1.2);
        }
    </style>
</head>

<body>
    <div id="main-container">
        <div id="canvas-container">
            <div id="info">
                Satelliten-Analyse (Solo & Permanent) | <span id="latitude">--</span>, <span id="longitude">--</span>
                <div id="time-display"><span id="currentTime">--:--:--</span></div>
                <progress id="progressBar" value="0" max="100" style="width:100%"></progress>
            </div>
            <div id="label-container"></div>
            <div id="loader">Lade System...</div>
        </div>

        <div id="data-sidebar">
            <h3 style="color:#00ffff; text-align:center;">STATUS</h3>
            <div id="legend" style="margin-bottom:10px;"></div>
            <button id="clear-tracks-btn"
                style="width:100%; margin-bottom:10px; background:#440000; border-color: #ff0000;">SPUREN
                L√ñSCHEN</button>
            <div id="satellite-table-container">
                <table id="satellite-table">
                    <!-- Hier ist die Checkbox-Spalte "Solo" -->
                    <thead>
                        <tr>
                            <th>Sys</th>
                            <th>ID</th>
                            <th>El</th>
                            <th>Az</th>
                            <th>SNR</th>
                            <th>Solo</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="controls">
        <select id="range-select">
            <option value="1h">Letzte 1 Std</option>
            <option value="12h">Letzte 12 Std</option>
            <option value="24h">Letzte 24 Std</option>
            <option value="7d">Letzte 7 Tage</option>
            <option value="all">Alles</option>
        </select>
        <button id="load-data-btn">Laden</button>
        <button id="play-pause-btn">Play</button>
        <input type="range" id="speed-slider" min="1" max="1000" value="50">
        <span id="speed-display">50x</span>
        <label>Spur:</label>
        <input type="range" id="trail-slider" min="100" max="20000" value="2000">
        <span id="trail-display">2000</span>
        <label>Zeit:</label>
        <input type="range" id="time-slider" min="0" max="0" value="0" style="width: 15%;">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- KONFIGURATION ---
        const EARTH_RADIUS_VISUAL = 5;
        const REAL_EARTH_RADIUS_KM = 6371;
        const MAX_JUMP_DISTANCE = 10.0;

        const ALTITUDE_GPS = 20200;
        const ALTITUDE_GLONASS = 19100;
        const ALTITUDE_GALILEO = 23000;
        const ALTITUDE_BEIDOU = 21500;

        // --- BERECHNUNGSHILFEN ---
        function getSatelliteAltitude(satId) {
            if (satId.startsWith('G')) return ALTITUDE_GPS;
            if (satId.startsWith('R')) return ALTITUDE_GLONASS;
            if (satId.startsWith('E')) return ALTITUDE_GALILEO;
            if (satId.startsWith('C')) return ALTITUDE_BEIDOU;
            return 20200;
        }

        function calculateSatellitePosition(userPosition, satInfo) {
            const alt = getSatelliteAltitude(satInfo.id);
            const orbitRadius = EARTH_RADIUS_VISUAL * ((REAL_EARTH_RADIUS_KM + alt) / REAL_EARTH_RADIUS_KM);

            const userUpVector = userPosition.clone().normalize();
            const rotationQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), userUpVector);
            const azimRad = THREE.MathUtils.degToRad(satInfo.azim - 90);
            const elevRad = THREE.MathUtils.degToRad(satInfo.elev);

            const sightLineDirection = new THREE.Vector3(
                Math.cos(elevRad) * Math.cos(azimRad),
                Math.sin(elevRad),
                Math.cos(elevRad) * Math.sin(azimRad)
            );
            sightLineDirection.applyQuaternion(rotationQuaternion).normalize();

            const a = 1;
            const b = 2 * userPosition.dot(sightLineDirection);
            const c = userPosition.lengthSq() - orbitRadius * orbitRadius;
            const discriminant = b * b - 4 * a * c;

            if (discriminant >= 0) {
                const t = (-b + Math.sqrt(discriminant)) / (2 * a);
                return userPosition.clone().add(sightLineDirection.multiplyScalar(t));
            } else {
                return sightLineDirection.multiplyScalar(orbitRadius);
            }
        }

        function getEarthRotation(datetime) {
            const date = new Date(datetime.replace(' ', 'T') + 'Z');
            const sec = (date.getUTCHours() * 3600) + (date.getUTCMinutes() * 60) + date.getUTCSeconds();
            return (sec / 86400) * 2 * Math.PI;
        }

        function getPosFromLatLon(lat, lon) {
            const latRad = THREE.MathUtils.degToRad(lat);
            const lonRad = THREE.MathUtils.degToRad(-lon);
            return new THREE.Vector3(
                EARTH_RADIUS_VISUAL * Math.cos(latRad) * Math.cos(lonRad),
                EARTH_RADIUS_VISUAL * Math.sin(latRad),
                EARTH_RADIUS_VISUAL * Math.cos(latRad) * Math.sin(lonRad)
            );
        }

        // --- GLOBALS ---
        let scene, camera, renderer, labelRenderer, controls, earth, userArrow, sun;
        let satelliteModel;
        let data = [];
        let satMap = new Map();

        let isPaused = true;
        let speed = 50;
        let maxPoints = 2000;
        let clock = new THREE.Clock();
        let timeAccumulator = 0;
        let currentIndex = 0;
        let soloId = null; // ID des aktuell ausgew√§hlten Satelliten (oder null)

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // --- INIT ---
        async function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 20, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
            document.getElementById('label-container').appendChild(labelRenderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0x666666));
            sun = new THREE.DirectionalLight(0xffffff, 2.0);
            scene.add(sun);

            try {
                const gltfLoader = new THREE.GLTFLoader();
                const [earthGltf, satGltf] = await Promise.all([
                    gltfLoader.loadAsync('earth.glb'),
                    gltfLoader.loadAsync('satellite.glb')
                ]);
                earth = earthGltf.scene;
                earth.scale.set(EARTH_RADIUS_VISUAL, EARTH_RADIUS_VISUAL, EARTH_RADIUS_VISUAL);
                scene.add(earth);

                satelliteModel = satGltf.scene;

                userArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 2, 0xff0000);
                earth.add(userArrow);

                document.getElementById('loader').style.display = 'none';
                setupUI();
                animate();
                loadData();
            } catch (e) {
                console.error(e);
                document.getElementById('loader').textContent = "Fehler beim Laden der Modelle.";
            }
        }

        // --- LOGIK ---
        async function loadData() {
            const btn = document.getElementById('load-data-btn');
            const range = document.getElementById('range-select').value;
            btn.disabled = true;
            btn.textContent = "L√§dt...";

            if (!isPaused) togglePlay();

            clearAll();

            try {
                const res = await fetch(`get_data_straight.php?range=${range}&t=${Date.now()}`);
                data = await res.json();

                if (data.length > 0) {
                    const first = data[0];
                    document.getElementById('latitude').textContent = parseFloat(first.lat).toFixed(4);
                    document.getElementById('longitude').textContent = parseFloat(first.lon).toFixed(4);
                }

                document.getElementById('progressBar').max = data.length - 1;
                document.getElementById('time-slider').max = data.length - 1;
                currentIndex = 0;
                updateFrame(0);

            } catch (e) {
                console.error(e);
                alert("Ladefehler");
            }
            btn.disabled = false;
            btn.textContent = "Laden";
        }

        function clearAll() {
            satMap.forEach(obj => {
                scene.remove(obj.mesh);
                scene.remove(obj.line);
                obj.label.element.remove();
            });
            document.querySelector('#satellite-table tbody').innerHTML = '';
            satMap.clear();
            data = [];
        }

        function updateFrame(idx) {
            if (!data[idx]) return;
            const frame = data[idx];

            earth.rotation.y = getEarthRotation(frame.datetime);

            const localPos = getPositionFromLatLon(frame.lat, frame.lon, 1);
            userArrow.position.copy(localPos.clone().normalize().multiplyScalar(0.99));
            userArrow.setDirection(localPos.clone().normalize());

            const worldPos = new THREE.Vector3();
            userArrow.getWorldPosition(worldPos);
            sun.position.copy(worldPos).normalize().multiplyScalar(100);

            document.getElementById('currentTime').textContent = frame.datetime;
            document.getElementById('progressBar').value = idx;
            document.getElementById('time-slider').value = idx;

            const activeIds = new Set();

            if (frame.satellites) {
                frame.satellites.forEach(s => {
                    activeIds.add(s.id);
                    let obj = satMap.get(s.id);

                    if (!obj) {
                        obj = createSatObj(s.id);
                        satMap.set(s.id, obj);
                    }

                    if (s.elev <= 0) {
                        obj.mesh.visible = false;
                        obj.label.visible = false;
                        updateRow(s.id, '--', '--', '--');
                        return;
                    }

                    const pos = calculateSatellitePosition(worldPos, s);

                    obj.mesh.visible = true;
                    obj.label.visible = true;
                    obj.mesh.position.copy(pos);
                    obj.mesh.lookAt(earth.position);

                    // Permanente Tracks: Punkt hinzuf√ºgen (auch wenn er springt)
                    obj.points.push(pos.clone());

                    // Trimmen
                    if (obj.points.length > maxPoints) obj.points.shift();

                    // Geometry Update
                    if (obj.points.length > 1) {
                        obj.line.geometry.setFromPoints(obj.points);
                        obj.line.visible = true;
                    }

                    updateRow(s.id, s.elev, s.azim, s.snr);
                });
            }

            satMap.forEach((obj, id) => {
                // Satellit fehlt im Frame -> Ausblenden (aber Track behalten!)
                if (!activeIds.has(id)) {
                    obj.mesh.visible = false;
                    obj.label.visible = false;
                    updateRow(id, '--', '--', '--', true);
                }

                // SOLO MODUS FILTER
                // Wenn ein Solo-Satellit gew√§hlt ist:
                if (soloId !== null) {
                    if (id === soloId) {
                        // Das ist der Auserw√§hlte!
                        // Mesh nur zeigen, wenn er auch wirklich da ist (aktiv war)
                        // Tracks IMMER zeigen (solange Punkte da sind)
                        if (activeIds.has(id) && obj.mesh.visible) {
                            // Mesh ist sichtbar, alles gut
                        }
                        // Tracks sichtbar machen
                        if (obj.points.length > 1) obj.line.visible = true;
                    } else {
                        // Das ist ein anderer -> ALLES Verstecken
                        obj.mesh.visible = false;
                        obj.label.visible = false;
                        obj.line.visible = false;
                    }
                } else {
                    // Kein Solo-Modus -> Alle Tracks sichtbar (wenn Punkte da)
                    if (obj.points.length > 1) obj.line.visible = true;
                }
            });
        }

        function createSatObj(id) {
            const mesh = satelliteModel.clone();
            mesh.scale.set(0.1, 0.1, 0.1);
            mesh.userData = { satId: id };
            mesh.traverse((child) => { child.userData = { satId: id }; });
            scene.add(mesh);

            const div = document.createElement('div');
            div.className = 'label-text';
            div.textContent = id;

            // Label Klick
            div.addEventListener('click', (e) => {
                e.stopPropagation();
                const cb = document.querySelector(`input[data-sat-id="${id}"]`);
                if (cb) {
                    cb.checked = !cb.checked;
                    toggleSolo(id, cb);
                }
            });

            const label = new THREE.CSS2DObject(div);
            label.position.set(0, 1, 0);
            mesh.add(label);

            const geo = new THREE.BufferGeometry();
            const mat = new THREE.LineBasicMaterial({ color: getSatColor(id), opacity: 0.5, transparent: true });
            const line = new THREE.Line(geo, mat);
            scene.add(line);

            const tbody = document.querySelector('#satellite-table tbody');
            const tr = document.createElement('tr');
            tr.id = `row-${id}`;
            tr.innerHTML = `
                <td><span style="color:${getSatColor(id, true)}">‚óè</span> ${getFlag(id)}</td>
                <td>${id}</td>
                <td class="el"></td><td class="az"></td><td class="snr"></td>
                <td><input type="checkbox" data-sat-id="${id}" onclick="toggleSolo('${id}', this)"></td>
            `;
            // Zeilen Klick
            tr.addEventListener('click', (e) => {
                if (e.target.type !== 'checkbox') {
                    const cb = tr.querySelector('input[type="checkbox"]');
                    cb.checked = !cb.checked;
                    toggleSolo(id, cb);
                }
            });

            tbody.appendChild(tr);

            return { mesh, label, line, points: [] };
        }

        function updateRow(id, el, az, snr, dim = false) {
            const tr = document.getElementById(`row-${id}`);
            if (!tr) return;
            tr.querySelector('.el').textContent = el;
            tr.querySelector('.az').textContent = az;
            tr.querySelector('.snr').textContent = snr;
            tr.style.color = dim ? '#555' : '#fff';
        }

        function getSatColor(id, hexStr = false) {
            let col = 0xffffff;
            let str = '#ffffff';
            if (id.startsWith('G')) { col = 0x00ff00; str = '#00ff00'; }
            else if (id.startsWith('R')) { col = 0xff0000; str = '#ff0000'; }
            else if (id.startsWith('E')) { col = 0xffff00; str = '#ffff00'; }
            else if (id.startsWith('C')) { col = 0x0088ff; str = '#0088ff'; }
            return hexStr ? str : col;
        }

        function getFlag(id) {
            if (id.startsWith('G')) return 'üá∫üá∏';
            if (id.startsWith('R')) return 'üá∑üá∫';
            if (id.startsWith('E')) return 'üá™üá∫';
            if (id.startsWith('C')) return 'üá®üá≥';
            return 'üõ∞Ô∏è';
        }

        // --- UI FUNCTIONS ---
        window.toggleSolo = (id, cb) => {
            if (cb.checked) {
                soloId = id;
                // Alle anderen Checkboxen deaktivieren
                document.querySelectorAll('input[type=checkbox]').forEach(c => { if (c !== cb) c.checked = false; });
            } else {
                soloId = null;
            }
            // Sofortiges Update
            updateFrame(currentIndex);
        };

        function togglePlay() {
            isPaused = !isPaused;
            document.getElementById('play-pause-btn').textContent = isPaused ? "Play" : "Pause";
        }

        // 3D Klick
        function onMouseClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const meshes = [];
            satMap.forEach(obj => { if (obj.mesh.visible) meshes.push(obj.mesh); });

            const intersects = raycaster.intersectObjects(meshes, true);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                // Suche das Root-Objekt mit der ID (kann ein Child sein)
                let obj = hit;
                while (obj && !obj.userData.satId) { obj = obj.parent; }

                if (obj && obj.userData.satId) {
                    const id = obj.userData.satId;
                    const cb = document.querySelector(`input[data-sat-id="${id}"]`);
                    if (cb) {
                        cb.checked = !cb.checked;
                        toggleSolo(id, cb);
                    }
                }
            }
        }

        function setupUI() {
            document.getElementById('load-data-btn').addEventListener('click', loadData);
            document.getElementById('play-pause-btn').addEventListener('click', togglePlay);

            document.getElementById('speed-slider').addEventListener('input', e => {
                speed = parseInt(e.target.value);
                document.getElementById('speed-display').textContent = speed + 'x';
            });

            document.getElementById('trail-slider').addEventListener('input', e => {
                maxPoints = parseInt(e.target.value);
                document.getElementById('trail-display').textContent = maxPoints;

                // Trimmen bei Bedarf
                if (maxPoints !== 20000) { // 20000 als "Unendlich"-Ersatz im Slider
                    satMap.forEach(obj => {
                        while (obj.points.length > maxPoints) obj.points.shift();
                    });
                }
            });

            document.getElementById('time-slider').addEventListener('input', e => {
                currentIndex = parseInt(e.target.value);
                updateFrame(currentIndex);
                if (!isPaused) togglePlay();
            });

            document.getElementById('clear-tracks-btn').addEventListener('click', () => {
                satMap.forEach(obj => {
                    obj.points = [];
                    obj.line.geometry.setFromPoints([]);
                });
            });

            document.getElementById('canvas-container').addEventListener('click', onMouseClick);

            window.addEventListener('resize', () => {
                camera.aspect = document.getElementById('canvas-container').clientWidth / document.getElementById('canvas-container').clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(document.getElementById('canvas-container').clientWidth, document.getElementById('canvas-container').clientHeight);
                labelRenderer.setSize(document.getElementById('canvas-container').clientWidth, document.getElementById('canvas-container').clientHeight);
            });
        }

        // --- ANIMATION LOOP (V4.3 Performance Fix) ---
        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();

            if (!isPaused && data.length > 0) {
                timeAccumulator += dt * speed;
                if (timeAccumulator >= 1.0) {
                    const steps = Math.floor(timeAccumulator);
                    currentIndex = (currentIndex + steps) % data.length;
                    timeAccumulator -= steps;
                    updateFrame(currentIndex);
                }
            }

            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();

    </script>
</body>

</html>